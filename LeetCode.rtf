[Arrays and Hashing]
 -Contains duplicate:
	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
	
	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
	
 -Valid Anagram:
	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
	
	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
			    in the second string, which is slower.
	
	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.

 -Two Sum:
	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
				target, return the indexes.
	
	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
				the index of the current key and the index of the found contained key.
	
	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
																gets removed and the time complexity goes down to O(n).
															
 -Group Anagrams:
 


 -Top K Frequent Elements:
	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
			  then remove that value from the list.
	
	-PriorityQueue.								  
	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
	
	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
	
 -Product of Array Except Self:
 	-The rest I didn't finish describing, since I got lazy

[Two Pointers]
 -Valid Palindrome:
	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything [replaceAll("[^a-zA-Z0-9]", "").toLowerCase();]. Check 	if the input string is empty, if yes -> return TRUE. Then use one for loop with two pointers, one at the beginning and one at the end. Both of them simultaniously iterate to the middle and check if each character from the beginning and the end are the same. If there's a mismatch return FALSE, else CONTINUE.

 -Two Sum II Input Array Is Sorted:
	-Place one pointer at the beginning and at the end of the array. "amountNeeded = target - array[beginningIndex]". Check if the "amountNeeded" is less than the number shown from the right-side pointer. If that's the case, move the right index 1 spot to the left and do the check again. If "amountNeeded" is greater than the number shown from the left-side pointer, then move the left index 1 spot to the right and do the check again. Eventually the "amountNeeded" will match with the number from the right idex and when that happens, return their places.

 -3Sum:
  - CURRENTLY ON HOLD

 -Container With Most Water:
	-DISCLAIMER:{I saw the solution first and then implemented it.} Create two pointers, one on the left side of the array and one on the right side of the array. Calculate the amount of water between them and mark it as highest amount if it's more than the previous highest amount. Then check if the value in the left pointer is higher than the valuein the right pointer. If that's the case, reduce the right pointer by one, otherwise increase the left pointer by one. Continue this loop until both pointers meet.

 -Trapping Rain Water:
	Traverse from left to right with two pointers at the spots [0] and [1]. Check if the rightValue is lower than the leftValue and if that's the case, calculate the difference between both values (that's the water that is going to get trapped) then increase the second pointer by one. If the rightValue is higher/ equal than the leftValue that means that no water can be trapped => update the total trapped water by the amount that has been calculated so far and set the two pointers as follows: begin = current higher Right end value, end = current higher Right end value +1. This loop will happen until we reach the highest point ever after which one there isn't a higher one. When that happens, we iterate to the end and remember at which index this highest point is and we discard all the collected water from that point on, since we don't know if there is any spillage on the right side. Then we do another reverse loop starting from the end with two pointers [endIndex] [endIndex-1] and we iterate with the above mentioned process until we reach the previously noted highest point.

	
[Sliding Window]
 -Best Time To Buy And Sell Stock:
	-DISCLAIMER:{Super retarted solution by me once again, atleast its O(n) and didn't use O(n^2) algo} Check for consecutive descending values in the beginning of the array(they are useless, we will never buy high and sell low) and note the next non-descending one as the beginning + if we reach the end it means that the whole array is descending => we can check that and return 0. Do the same but from the end - ascending values. Then iterate trough the array from the first relevant beginning entry to the first relevant end entry and note the index of the highest and the lowest number. If the index of the lowest number is before the index of the highest number return prices[highestIndex]-prices[lowestIndex]. In the other case do 2 more for loops: From the highest index backwards and from the lowest index forwards. Note the greatest difference in each of those two loops and return it.

 -Length Of Longest Substring:
	-I did two solutions, but both of them failed on the last test becase it ran for too long (35k) String. 
	[1] Create a set holding the current characters and iterate trough the input String. Each time check if the new character is contained by the set. If that's the case, find the position of the character and update the iterating pointer one to the right of the first appearance of the repeated character, clear the set and continue from the new place.

	[2] Sliding window implementation, but still 1 test case short. Create a Deque and start iterating and adding the characters to it until we find a duplicate. If found, check if the current Deque size is bigger than the highest number that we have found so far. Then continue removing characters from the head of the Deque until the contains() check fails and afterwards continue as normal - incrementing the right pointer and continuing to add new characters to the Deque.

	[3] I finally gave up with this final test and asked ChatGPT for a solution. We create an array to keep track of the index of the last occurance of each character new int[256]. Create left and right pointer and while right<string.len, get the character at the right pointer and check if the character has been encountered withing the current window. If yes, update left to charIndex[character]. If not, calculate the length of the current substring and update the longestSubstringCount if necessary. Then update the character's index to the current position charIndex[character] = right + 1 and move the right pointer to the next character

 -Longest Repeating Character Replacement:
	-CURRENTLY ON HOLD

 -Permutation In String:
 	-Improvement from 1000ms to 130ms or so with the use of array, containing the letters instead of a HashMap, still not the most optimal solution, should do this problem again at some point later on.

	Create an array for the 26 letters in the alphabet and iterate trough the first string and update their frequency count. Create a copy of it and iterate trough the second(longer) string and reduce the occurances by one for each letter in it. Then iterate trough that array and if there's a character, which has been used in the first string but not in the second one, it's value should be > 0. If that's not the case return false (cannot have it being in the substring string part, but not in the second string). Then using the sliding window method iterate trough the second string. The window has the length of the first string. If the character in the string occurs in the array, reduce the array's value by one and update the left pointer and a counter. The counter is there to check if it matches the first string's length. If that's the case, return true (a permutated substring has been found). If the character in the string doesn't occur in the array, update the left pointer to the initial left pointer's value +1, update the right pointer by one, reset the counter to 0 and return the array to it's previous state (before making the changes during the current iteration). That way we creep slowly trough the second string, we are updating the window only by 1 for each iteration, which is kinda slow. 

 -Minimum Window Substring:

	-The character is from the substring and hasn't occured yet: decrease,