Index: NeetCode/Stack/ValidParentheses.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/ValidParentheses.java b/NeetCode/Stack/ValidParentheses.java
new file mode 100644
--- /dev/null	(date 1701429983414)
+++ b/NeetCode/Stack/ValidParentheses.java	(date 1701429983414)
@@ -0,0 +1,44 @@
+package Stack;
+
+import java.util.HashMap;
+import java.util.Stack;
+
+public class ValidParentheses {
+
+    public static boolean isValid(String s) {
+
+        Stack<Character> stack = new Stack<Character>();
+        HashMap<Character, Character> mapOppositeBrackets = new HashMap<>();
+
+        mapOppositeBrackets.put(')', '(');
+        mapOppositeBrackets.put(']', '[');
+        mapOppositeBrackets.put('}', '{');
+
+        if (s.length() % 2 != 0 || mapOppositeBrackets.keySet().contains(s.charAt(0))) {
+            return false;
+        }
+
+        for (int i = 0; i < s.length(); i++) {
+            char currentBracket = s.charAt(i);
+            if (currentBracket == '(' || currentBracket == '{' || currentBracket == '[') {
+                stack.push(currentBracket);
+            } else {
+                if (stack.isEmpty()) {
+                    return false;
+                }
+
+                if (mapOppositeBrackets.get(currentBracket) == stack.peek()) {
+
+                    stack.pop();
+                } else {
+                    return false;
+                }
+            }
+        }
+        return stack.isEmpty();
+
+    }
+
+    public static void main(String[] args) {
+    }
+}
Index: NeetCode/Stack/CarFleet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/CarFleet.java b/NeetCode/Stack/CarFleet.java
new file mode 100644
--- /dev/null	(date 1701429884440)
+++ b/NeetCode/Stack/CarFleet.java	(date 1701429884440)
@@ -0,0 +1,35 @@
+package Stack;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class CarFleet {
+
+    public static int carFleet(int target, int[] position, int[] speed) {
+        Map<Double, Double> carMap = new TreeMap<>(Collections.reverseOrder());
+        int amountOfCarFleets = 0;
+        double slowestTimeToReachEnd = -1;
+
+        for (int i = 0; i < position.length; i++) {
+            double carPosition = position[i];
+            double carSpeed = speed[i];
+            double timeToReachEnd = (target - carPosition) / carSpeed;
+
+            carMap.put(carPosition, timeToReachEnd);
+        }
+
+        for (double timeToEnd : carMap.values()) {
+            if (timeToEnd > slowestTimeToReachEnd) {
+                slowestTimeToReachEnd = timeToEnd;
+                amountOfCarFleets++;
+            }
+        }
+
+        return amountOfCarFleets;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: NeetCode/TwoPointer/TwoSumIIInputArrayIsSorted.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/TwoPointer/TwoSumIIInputArrayIsSorted.java b/NeetCode/TwoPointer/TwoSumIIInputArrayIsSorted.java
new file mode 100644
--- /dev/null	(date 1701430064225)
+++ b/NeetCode/TwoPointer/TwoSumIIInputArrayIsSorted.java	(date 1701430064225)
@@ -0,0 +1,31 @@
+package TwoPointer;
+
+import java.util.Arrays;
+
+public class TwoSumIIInputArrayIsSorted {
+    public static int[] twoSum(int[] numbers, int target) {
+
+        for (int i = 0, j = numbers.length - 1; i < j; ) {
+            int neededAmount = target - numbers[i];
+
+            if (neededAmount < numbers[j]) {
+                j--;
+                continue;
+            } else if (neededAmount > numbers[j]) {
+                i++;
+                continue;
+            } else {
+                return new int[]{i + 1, j + 1};
+            }
+        }
+        return null;
+    }
+
+    public static void main(String[] args) {
+        int[] numbers = {2, 7, 11, 15};
+        int target = 9;
+
+        System.out.println(Arrays.toString(twoSum(numbers, target)));
+    }
+
+}
Index: NeetCode/BinarySearch/SearchingA2DMatrix.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/BinarySearch/SearchingA2DMatrix.java b/NeetCode/BinarySearch/SearchingA2DMatrix.java
new file mode 100644
--- /dev/null	(date 1701429706109)
+++ b/NeetCode/BinarySearch/SearchingA2DMatrix.java	(date 1701429706109)
@@ -0,0 +1,33 @@
+package BinarySearch;
+
+public class SearchingA2DMatrix {
+    public static boolean searchMatrix(int[][] matrix, int target) {
+
+
+        int rows = matrix.length;
+        int columns = matrix[0].length;
+
+        int left = 0;
+        int right = rows * columns - 1;
+
+        while (left <= right) {
+            int middle = left + (right - left) / 2;
+
+            if (matrix[middle / columns][middle % columns] > target) {
+                right = middle - 1;
+            } else if (matrix[middle / columns][middle % columns] < target) {
+                left = middle + 1;
+            } else {
+                return true;
+            }
+        }
+
+
+        return false;
+
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: NeetCode/BinarySearch/FindMinimumInRotatedSortedArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/BinarySearch/FindMinimumInRotatedSortedArray.java b/NeetCode/BinarySearch/FindMinimumInRotatedSortedArray.java
new file mode 100644
--- /dev/null	(date 1701429684124)
+++ b/NeetCode/BinarySearch/FindMinimumInRotatedSortedArray.java	(date 1701429684124)
@@ -0,0 +1,45 @@
+package BinarySearch;
+
+public class FindMinimumInRotatedSortedArray {
+
+    public int findMin(int[] nums) {
+
+        if (nums.length == 1) {
+            return nums[0];
+        }
+
+        int left = 0;
+        int right = nums.length - 1;
+
+
+        while (left <= right) {
+
+            if (right - left == 1) {
+                return Math.min(nums[left], nums[right]);
+            } else if (right == left) {
+                return nums[left];
+            }
+
+            int middle = left + (right - left) / 2;
+
+            if (nums[middle] > nums[middle + 1]) {
+                return nums[middle + 1];
+            } else if (nums[middle] > nums[right]) {
+                left = middle + 1;
+            } else if (nums[middle] > nums[left]) {
+                right = middle - 1;
+            } else if (nums[middle] < nums[middle + 1] && nums[middle] < nums[middle - 1]) {
+                return nums[middle];
+            } else if (nums[middle] < nums[right] && nums[middle] < nums[left]) {
+                right = middle - 1;
+            }
+        }
+
+        return left;
+
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: NeetCode/TwoPointer/ValidPalindrome.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/TwoPointer/ValidPalindrome.java b/NeetCode/TwoPointer/ValidPalindrome.java
new file mode 100644
--- /dev/null	(date 1701430064230)
+++ b/NeetCode/TwoPointer/ValidPalindrome.java	(date 1701430064230)
@@ -0,0 +1,28 @@
+package TwoPointer;
+
+public class ValidPalindrome {
+
+    public static boolean isPalindrome(String s) {
+
+        String clearedInput = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
+
+        if (clearedInput == "") {
+            return true;
+        }
+
+        for (int i = 0, j = clearedInput.length() - 1; i < clearedInput.length() / 2; i++, j--) {
+            if (clearedInput.charAt(i) != clearedInput.charAt(j)) {
+                return false;
+            }
+        }
+
+        return true;
+
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+
+}
\ No newline at end of file
Index: NeetCode/TwoPointer/ThreeSum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/TwoPointer/ThreeSum.java b/NeetCode/TwoPointer/ThreeSum.java
new file mode 100644
--- /dev/null	(date 1701430019743)
+++ b/NeetCode/TwoPointer/ThreeSum.java	(date 1701430019743)
@@ -0,0 +1,20 @@
+package TwoPointer;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public class ThreeSum {
+    public static List<List<Integer>> threeSum(int[] nums) {
+
+
+        return null;
+
+    }
+
+    public static void main(String[] args) {
+
+    }
+
+}
Index: NeetCode/TwoPointer/TrappingRainWater.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/TwoPointer/TrappingRainWater.java b/NeetCode/TwoPointer/TrappingRainWater.java
new file mode 100644
--- /dev/null	(date 1701430114001)
+++ b/NeetCode/TwoPointer/TrappingRainWater.java	(date 1701430114001)
@@ -0,0 +1,81 @@
+package TwoPointer;
+
+public class TrappingRainWater {
+
+    public static int trap(int[] height) {
+
+        if (height.length == 1 || height.length == 2) { // Both cases there will be no trapped water
+            return 0;
+        }
+
+        int filledArea = 0;
+        int toBeFilled = 0;
+
+        int finalHighest = -1; // Used to mark the highest point in the graph, after which we start the reverse
+        // algorithm.
+
+        for (int begin = 0, end = 1; end < height.length; ) {// Begin from left to right [0] [1]
+
+            int leftValue = height[begin];
+            int rightValue = height[end];
+
+            if (rightValue < leftValue) {// In this case there will be trapped water
+
+                end++;// Update the right pointer
+                toBeFilled += leftValue - rightValue;// Calculate the trapped water
+
+            } else { // The right value is higher than the left value => We begin the algorith from
+                // the beginning but with new two pointers
+                filledArea += toBeFilled;// Update the trapped water so far
+                begin = end; // Update the new pointers values
+                end = end + 1;
+                toBeFilled = 0;
+            }
+
+            if (end == height.length) {// End of the array has been reached => mark the highest latest point that we
+                // have seen
+                finalHighest = begin;
+            }
+
+        }
+
+        filledArea = filledArea > 0 ? filledArea : 0; // There are cases, where we have collected negative water eg.
+        // {4,2,3}
+
+        toBeFilled = 0;
+        for (int reverseBegin = height.length - 1, reverseEnd = height.length - 2; reverseBegin > finalHighest; ) {
+            // Same algorithm, but this time backwards until we reach the previously marked
+            // highest point
+
+            int rightValue = height[reverseBegin];
+            int leftValue = height[reverseEnd];
+
+            if (leftValue < rightValue) {
+
+                toBeFilled += rightValue - leftValue;
+                reverseEnd--;
+            } else {
+                filledArea += toBeFilled;
+                reverseBegin = reverseEnd;
+                reverseEnd = reverseEnd - 1;
+                toBeFilled = 0;
+
+            }
+
+        }
+
+        return filledArea;
+
+    }
+
+    public static void main(String[] args) {
+        // int[] height = { 4, 2, 3 };
+        // int[] height2 = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
+        // int[] height3 = { 4, 2, 0, 3, 2, 5 };
+        // int[] height4 = { 5, 5, 2, 6, 6, 3 };
+        int[] height5 = {4, 3};
+
+        System.out.println(trap(height5));
+    }
+
+}
Index: NeetCode/BinarySearch/SearchInRotatedSortedArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/BinarySearch/SearchInRotatedSortedArray.java b/NeetCode/BinarySearch/SearchInRotatedSortedArray.java
new file mode 100644
--- /dev/null	(date 1701429706103)
+++ b/NeetCode/BinarySearch/SearchInRotatedSortedArray.java	(date 1701429706103)
@@ -0,0 +1,75 @@
+package BinarySearch;
+
+public class SearchInRotatedSortedArray {
+
+    public static int search(int[] nums, int target) {
+
+        int left = 0;
+        int right = nums.length - 1;
+
+        while (left <= right) {
+
+            if (left == right) {
+                return (nums[left] == target) ? left : -1;
+            }
+
+            if (target > nums[right] && target < nums[left]) {
+                return -1;
+            }
+
+            int middle = left + (right - left) / 2;
+
+            if (nums[middle] == target) {
+                return middle;
+            }
+
+            if (nums[left] == target || nums[right] == target) {
+                return (nums[left] == target) ? left : right;
+            }
+
+            if (nums[left] > nums[right]) {
+                if (nums[middle] > nums[left]) {
+
+                    if (target < nums[middle]) {
+                        if (target > nums[left]) {
+                            right = middle - 1;
+                        } else {
+                            left = middle + 1;
+                        }
+
+                    } else {
+                        left = middle + 1;
+                    }
+                } else {
+                    if (target < nums[middle]) {
+                        right = middle - 1;
+                    } else {
+                        if (target > nums[left]) {
+                            right = middle - 1;
+                            continue;
+
+                        }
+                        left = middle + 1;
+                    }
+                }
+
+            } else if (nums[left] < nums[right]) {
+                if (nums[middle] > target) {
+                    right = middle - 1;
+                } else if (nums[middle] < target) {
+                    left = middle + 1;
+                } else {
+                    return middle;
+                }
+            }
+        }
+
+        return -1;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
+
+
Index: NeetCode/BinarySearch/KokoEatingBananas.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/BinarySearch/KokoEatingBananas.java b/NeetCode/BinarySearch/KokoEatingBananas.java
new file mode 100644
--- /dev/null	(date 1701429684165)
+++ b/NeetCode/BinarySearch/KokoEatingBananas.java	(date 1701429684165)
@@ -0,0 +1,53 @@
+package BinarySearch;
+
+import java.util.Arrays;
+
+//UNSOLVED
+public class KokoEatingBananas {
+
+    public static int minEatingSpeed(int[] piles, int h) {
+
+        Arrays.sort(piles);
+
+        if (piles.length == h) {
+            return piles[piles.length - 1];
+        }
+
+
+        int maxRepeats = h - piles.length;
+
+
+        //when repeats are less than the input array length
+        // if theres only 1 repeat possible, its always on the last element
+        // 2 repeats = 2 last/ last-secondToLast
+        // 3 repeats = 3last/ 2last-1secondToLast/ last:last-1:last-2
+
+
+        //when repeats are more or equal to the input array len
+        //
+
+        int totalSum = Arrays.stream(piles).sum();
+
+
+        for (int i = piles.length - 1; i >= 0; i--) {
+
+        }
+
+        int speed = 0;
+
+        return speed;
+
+    }
+
+
+    public static void main(String[] args) {
+
+//        int[] piles = {4,11,20,23,30};  // 1repeat
+//        int h = 6;
+
+        int[] piles = {3, 6, 7, 11};
+        int h = 8;
+        System.out.println(minEatingSpeed(piles, h));
+    }
+
+}
Index: NeetCode/TwoPointer/ContainerWithMostWater.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/TwoPointer/ContainerWithMostWater.java b/NeetCode/TwoPointer/ContainerWithMostWater.java
new file mode 100644
--- /dev/null	(date 1701255573510)
+++ b/NeetCode/TwoPointer/ContainerWithMostWater.java	(date 1701255573510)
@@ -0,0 +1,35 @@
+package TwoPointer;
+
+public class ContainerWithMostWater {
+
+   public static int maxArea(int[] height) {
+
+      int maxAreaResult = 0;
+
+      for (int leftPointer = 0, rightPointer = height.length - 1; leftPointer < rightPointer;) {
+         int leftHeight = height[leftPointer];
+         int rightHeight = height[rightPointer];
+         int pointerDifference = rightPointer - leftPointer;
+
+         int currentArea = (leftHeight > rightHeight ? rightHeight * pointerDifference
+               : leftHeight * pointerDifference);
+
+         if (currentArea > maxAreaResult) {
+            maxAreaResult = currentArea;
+         }
+
+         if (height[leftPointer] > height[rightPointer]) {
+            rightPointer--;
+         } else {
+            leftPointer++;
+         }
+      }
+
+      return maxAreaResult;
+   }
+
+   public static void main(String[] args) {
+
+   }
+
+}
Index: NeetCode/SlidingWindow/BestTimeToBuyAndSellStock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/SlidingWindow/BestTimeToBuyAndSellStock.java b/NeetCode/SlidingWindow/BestTimeToBuyAndSellStock.java
new file mode 100644
--- /dev/null	(date 1701429730934)
+++ b/NeetCode/SlidingWindow/BestTimeToBuyAndSellStock.java	(date 1701429730934)
@@ -0,0 +1,82 @@
+package SlidingWindow;
+
+//TODO redo the problem
+public class BestTimeToBuyAndSellStock {
+    public static int maxProfit(int[] prices) {
+
+        int maxProfit = 0;
+        if (prices.length <= 1) {
+            return maxProfit;
+        }
+
+        int highestValue = prices[0];
+        int lowestValue = prices[0];
+        boolean isDescendingArray = true;
+        int irrelevantEndEntriesCounter = 0;
+        int irrelevantBeginEntriesCounter = 0;
+
+        for (int end = prices.length - 1; end > 0 && prices[end] < prices[end - 1]; end--) {
+            irrelevantEndEntriesCounter++;
+        }
+
+        if (irrelevantEndEntriesCounter + 1 == prices.length) {
+            return 0;
+        }
+
+        for (int i = 1; i < prices.length - irrelevantEndEntriesCounter; i++) {
+            if (isDescendingArray) {
+                if (prices[i] < prices[i - 1]) {
+                    irrelevantBeginEntriesCounter++;
+                } else {
+                    break;
+                }
+            }
+        }
+
+        int indexOfHighest = irrelevantBeginEntriesCounter;
+        int indexOfLowest = irrelevantBeginEntriesCounter;
+        for (int i = irrelevantBeginEntriesCounter; i < prices.length - irrelevantEndEntriesCounter; i++) {
+            int currentValue = prices[i];
+
+            if (currentValue > prices[indexOfHighest]) {
+                indexOfHighest = i;
+            }
+
+            if (currentValue < prices[indexOfLowest]) {
+                indexOfLowest = i;
+            }
+
+        }
+
+        if (indexOfHighest > indexOfLowest) {
+            return prices[indexOfHighest] - prices[indexOfLowest];
+        }
+
+        highestValue = prices[indexOfHighest];
+        lowestValue = prices[indexOfLowest];
+
+        int highestDifferenceCalculatedWithHighest = 0;
+        int highestDifferenceCalculatedWithLowest = 0;
+
+        for (int i = indexOfHighest; i >= 0 + irrelevantBeginEntriesCounter; i--) {
+            if (highestValue - prices[i] > highestDifferenceCalculatedWithHighest) {
+                highestDifferenceCalculatedWithHighest = highestValue - prices[i];
+            }
+        }
+
+        for (int i = indexOfLowest; i < prices.length - irrelevantEndEntriesCounter; i++) {
+            if (prices[i] - lowestValue > highestDifferenceCalculatedWithLowest) {
+                highestDifferenceCalculatedWithLowest = prices[i] - lowestValue;
+            }
+        }
+
+        return Math.max(highestDifferenceCalculatedWithLowest, highestDifferenceCalculatedWithHighest);
+
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+
+}
Index: NeetCode/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java b/NeetCode/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java
new file mode 100644
--- /dev/null	(date 1701429781165)
+++ b/NeetCode/SlidingWindow/LongestSubstringWithoutRepeatingCharacters.java	(date 1701429781165)
@@ -0,0 +1,41 @@
+package SlidingWindow;
+
+
+public class LongestSubstringWithoutRepeatingCharacters {
+    public static int lengthOfLongestSubstring(String s) {
+
+        int n = s.length();
+        if (n <= 1) {
+            return n; // If the string has 0 or 1 characters, return its length (no repeating
+            // characters possible).
+        }
+
+        int[] charIndex = new int[256]; // An array to keep track of the index of the last occurrence of each character
+        // (assuming ASCII characters).
+        int longestSubstringCount = 0; // To store the length of the longest substring without repeating characters.
+        int left = 0; // The left pointer of the sliding window.
+        int right = 0; // The right pointer of the sliding window.
+
+        while (right < n) {
+            char character = s.charAt(right); // Get the character at the right pointer.
+            if (charIndex[character] > left) {
+                // If the character has been encountered within the current window, move the
+                // left pointer to the next position after the previous occurrence.
+                left = charIndex[character];
+            }
+            // Calculate the length of the current substring and update the
+            // longestSubstringCount if necessary.
+            longestSubstringCount = Math.max(longestSubstringCount, right - left + 1);
+            // Update the character's index to the current position.
+            charIndex[character] = right + 1;
+            right++; // Move the right pointer to the next character.
+        }
+
+        return longestSubstringCount; // Return the length of the longest substring without repeating characters.
+
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: NeetCode/SlidingWindow/LongestRepeatingCharacterReplacement.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/SlidingWindow/LongestRepeatingCharacterReplacement.java b/NeetCode/SlidingWindow/LongestRepeatingCharacterReplacement.java
new file mode 100644
--- /dev/null	(date 1701429764903)
+++ b/NeetCode/SlidingWindow/LongestRepeatingCharacterReplacement.java	(date 1701429764903)
@@ -0,0 +1,15 @@
+package SlidingWindow;
+
+//TODO do the problem
+public class LongestRepeatingCharacterReplacement {
+
+    public static int characterReplacement(String s, int k) {
+
+        return 0;
+    }
+
+    public static void main(String[] args) {
+
+    }
+
+}
Index: NeetCode/SlidingWindow/PermutationInString.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/SlidingWindow/PermutationInString.java b/NeetCode/SlidingWindow/PermutationInString.java
new file mode 100644
--- /dev/null	(date 1701429850567)
+++ b/NeetCode/SlidingWindow/PermutationInString.java	(date 1701429850567)
@@ -0,0 +1,62 @@
+package SlidingWindow;
+
+public class PermutationInString {
+
+    public static boolean checkInclusion(String s1, String s2) {
+        int[] usedLetters2 = new int[26];
+
+        for (int i = 0; i < s1.length(); i++) {
+            char currentCharacter = s1.charAt(i);
+            usedLetters2[currentCharacter - 'a']++;
+        }
+
+        int[] tempUsedLetters = usedLetters2.clone();
+
+        for (int i = 0; i < s2.length(); i++) {
+            char currentCharacter = s2.charAt(i);
+            if (tempUsedLetters[currentCharacter - 'a'] != 0) {
+                tempUsedLetters[currentCharacter - 'a']--;
+            }
+        }
+
+        for (int amountOfLetters : tempUsedLetters) {
+            if (amountOfLetters > 0) {
+                return false;
+            }
+        }
+
+        tempUsedLetters = usedLetters2.clone();
+
+        int counter = 0;
+        int left = 0;
+        int initialLeft = 0;
+        int right = s1.length() - 1;
+
+        while (right < s2.length()) {
+            char currentCharacter = s2.charAt(left);
+
+            if (usedLetters2[currentCharacter - 'a'] > 0) {
+                usedLetters2[currentCharacter - 'a']--;
+                counter++;
+                left++;
+            } else {
+                left = initialLeft + 1;
+                right++;
+                initialLeft = left;
+                counter = 0;
+                usedLetters2 = tempUsedLetters.clone();
+            }
+
+            if (counter == s1.length()) {
+                return true;
+            }
+
+        }
+
+        return false;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: NeetCode/SlidingWindow/MinimumWindowSubstring.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/SlidingWindow/MinimumWindowSubstring.java b/NeetCode/SlidingWindow/MinimumWindowSubstring.java
new file mode 100644
--- /dev/null	(date 1701429840699)
+++ b/NeetCode/SlidingWindow/MinimumWindowSubstring.java	(date 1701429840699)
@@ -0,0 +1,18 @@
+package SlidingWindow;
+//TODO do the problem
+
+import java.util.ArrayDeque;
+import java.util.Deque;
+
+public class MinimumWindowSubstring {
+    public static String minWindow(String s, String t) {
+
+        return "";
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+
+}
Index: DailyChallenges/November2023/DiagonalTraverseII.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/DiagonalTraverseII.java b/DailyChallenges/November2023/DiagonalTraverseII.java
new file mode 100644
--- /dev/null	(date 1701429490912)
+++ b/DailyChallenges/November2023/DiagonalTraverseII.java	(date 1701429490912)
@@ -0,0 +1,39 @@
+package DailyChallenges.November2023;
+// https://leetcode.com/problems/diagonal-traverse-ii/solutions/597698/java-c-hashmap-with-picture-clean-code-o-n/?envType=daily-question&envId=2023-11-22
+// SOLVED
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.LinkedHashMap;
+import java.util.List;
+
+public class DiagonalTraverseII {
+
+    public static int[] findDiagonalOrder(List<List<Integer>> nums) {
+
+        LinkedHashMap<Integer, Deque<Integer>> map = new LinkedHashMap<>();
+        List<Integer> finalOrder = new ArrayList<>();
+
+        for (int i = 0; i < nums.size(); i++) {
+            for (int j = 0; j < nums.get(i).size(); j++) {
+                int sum = i + j;
+                int currentNumber = nums.get(i).get(j);
+
+                map.computeIfAbsent(sum, k -> new ArrayDeque<>()).addFirst(currentNumber);
+            }
+        }
+
+        for (Deque<Integer> numbers : map.values()) {
+            finalOrder.addAll(numbers);
+        }
+
+        return finalOrder.stream().mapToInt(Integer::intValue).toArray();
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+}
Index: DailyChallenges/November2023/CountNicePairsInArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/CountNicePairsInArray.java b/DailyChallenges/November2023/CountNicePairsInArray.java
new file mode 100644
--- /dev/null	(date 1701429392616)
+++ b/DailyChallenges/November2023/CountNicePairsInArray.java	(date 1701429392616)
@@ -0,0 +1,41 @@
+package DailyChallenges.November2023;
+// https://leetcode.com/problems/count-nice-pairs-in-an-array/?envType=daily-question&envId=2023-11-21
+// SOLVED
+
+import java.util.HashMap;
+
+public class CountNicePairsInArray {
+
+    public static int rev(int x) {
+        int result = 0;
+        while (x != 0) {
+            int digit = x % 10;
+            x /= 10;
+            result = result * 10 + digit;
+        }
+        return result;
+    }
+
+    public static int countNicePairs(int[] nums) {
+
+        HashMap<Integer, Integer> map = new HashMap<>();
+        int nicePairsCount = 0;
+        final int MOD = (int) (Math.pow(10, 9) + 7);
+
+        for (int num : nums) {
+            int neededSum = num - rev(num);
+
+            if (map.keySet().contains(neededSum)) {
+                nicePairsCount = (nicePairsCount + map.get(neededSum)) % MOD;
+                map.put(neededSum, map.get(neededSum) + 1);
+            } else {
+                map.put(neededSum, 1);
+            }
+        }
+        return nicePairsCount % MOD;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: DailyChallenges/November2023/ArithmeticSubarrays.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/ArithmeticSubarrays.java b/DailyChallenges/November2023/ArithmeticSubarrays.java
new file mode 100644
--- /dev/null	(date 1701423076444)
+++ b/DailyChallenges/November2023/ArithmeticSubarrays.java	(date 1701423076444)
@@ -0,0 +1,43 @@
+package DailyChallenges.November2023;
+//https://leetcode.com/problems/arithmetic-subarrays/description/?envType=daily-question&envId=2023-11-23
+// SOLVED
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ArithmeticSubarrays {
+
+    public static List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
+
+        List<Boolean> result = new ArrayList<>();
+        boolean isSubarayGood = true;
+        for (int i = 0; i < l.length; i++) {
+
+            int[] tempSubarray = new int[r[i] - l[i] + 1];
+            tempSubarray = Arrays.copyOfRange(nums, l[i], r[i] + 1);
+            Arrays.sort(tempSubarray);
+
+            int initialDifference = tempSubarray[1] - tempSubarray[0];
+            for (int j = 1; j < tempSubarray.length - 1; j++) {
+                if (tempSubarray[j + 1] - tempSubarray[j] != initialDifference) {
+                    isSubarayGood = false;
+                    break;
+                }
+            }
+            result.add(isSubarayGood);
+            isSubarayGood = true;
+        }
+
+        return result;
+    }
+
+    public static void main(String[] args) {
+
+        int[] nums = {4, 6, 5, 9, 3, 7};
+        int[] l = {0, 0, 2};
+        int[] r = {2, 3, 5};
+
+        System.out.println(checkArithmeticSubarrays(nums, l, r));
+    }
+}
Index: DailyChallenges/November2023/MaximumNumberOfCoinsYouCanGet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/MaximumNumberOfCoinsYouCanGet.java b/DailyChallenges/November2023/MaximumNumberOfCoinsYouCanGet.java
new file mode 100644
--- /dev/null	(date 1701423076391)
+++ b/DailyChallenges/November2023/MaximumNumberOfCoinsYouCanGet.java	(date 1701423076391)
@@ -0,0 +1,31 @@
+package DailyChallenges.November2023;
+
+// https://leetcode.com/problems/maximum-number-of-coins-you-can-get/description/?envType=daily-question&envId=2023-11-24
+// SOLVED
+
+import java.util.Arrays;
+
+public class MaximumNumberOfCoinsYouCanGet {
+
+    public static int maxCoins(int[] piles) {
+
+        int result = 0;
+        Arrays.sort(piles);
+
+        int playerIndex = piles.length - 2;
+
+        while (playerIndex >= piles.length / 3) {
+            result += piles[playerIndex];
+            playerIndex -= 2;
+        }
+        return result;
+
+    }
+
+    public static void main(String[] args) {
+
+        int[] piles = {2, 4, 1, 2, 7, 8};
+
+        System.out.println(maxCoins(piles));
+    }
+}
Index: DailyChallenges/November2023/MinimumAmountOfTimeToCollectGarbage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/MinimumAmountOfTimeToCollectGarbage.java b/DailyChallenges/November2023/MinimumAmountOfTimeToCollectGarbage.java
new file mode 100644
--- /dev/null	(date 1701429643559)
+++ b/DailyChallenges/November2023/MinimumAmountOfTimeToCollectGarbage.java	(date 1701429643559)
@@ -0,0 +1,37 @@
+package DailyChallenges.November2023;
+
+//https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/?envType=daily-question&envId=2023-11-20
+// SOLVED
+public class MinimumAmountOfTimeToCollectGarbage {
+    public static int garbageCollection(String[] garbage, int[] travel) {
+
+        int totalMinutes = 0;
+        int lastSeenM = -1;
+        int lastSeenG = -1;
+        int lastSeenP = -1;
+
+        for (int i = 0; i < garbage.length; i++) {
+            totalMinutes += garbage[i].length();
+            lastSeenM = garbage[i].contains("M") ? i : lastSeenM;
+            lastSeenG = garbage[i].contains("G") ? i : lastSeenG;
+            lastSeenP = garbage[i].contains("P") ? i : lastSeenP;
+        }
+
+        for (int j = 0; j < Math.max(Math.max(lastSeenP, lastSeenM), lastSeenG); j++) {
+            if (j < lastSeenG) {
+                totalMinutes += travel[j];
+            }
+            if (j < lastSeenM) {
+                totalMinutes += travel[j];
+            }
+            if (j < lastSeenP) {
+                totalMinutes += travel[j];
+            }
+        }
+        return totalMinutes;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: Medium/RotateArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Medium/RotateArray.java b/Medium/RotateArray.java
new file mode 100644
--- /dev/null	(date 1701428553558)
+++ b/Medium/RotateArray.java	(date 1701428553558)
@@ -0,0 +1,67 @@
+package Medium;
+//https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150
+//SOLVED
+
+import java.util.Arrays;
+
+public class RotateArray {
+    public static void rotate(int[] nums, int k) {
+
+        if (nums.length == 1 || k == 0 || k == nums.length) {
+            return;
+        }
+        int offset = k % nums.length;
+        int counter = 0;
+
+        int currentIndex = 0;
+        int previousIndex = currentIndex - offset > 0 ? currentIndex - offset : nums.length + currentIndex - offset;
+        int tempHolder = nums[previousIndex];
+
+        if (nums.length % 2 != 0 && nums.length % previousIndex != 0) {
+            while (counter < nums.length) {
+                int toBeInserted = tempHolder;
+                tempHolder = nums[currentIndex];
+                nums[currentIndex] = toBeInserted;
+                currentIndex = (currentIndex + offset) % nums.length;
+                counter++;
+            }
+        } else {
+            int beginIndex = 0;
+            while (counter < nums.length) {
+                boolean isThereLoop = false;
+                currentIndex = beginIndex;
+                previousIndex = currentIndex - offset > 0 ? currentIndex - offset : nums.length + currentIndex - offset;
+                tempHolder = nums[previousIndex];
+
+                while (!isThereLoop) {
+                    int toBeInserted = tempHolder;
+                    tempHolder = nums[currentIndex];
+                    nums[currentIndex] = toBeInserted;
+                    currentIndex = (currentIndex + offset) % nums.length;
+                    counter++;
+
+                    if (currentIndex == beginIndex) {
+                        isThereLoop = true;
+                    }
+                }
+                beginIndex++;
+            }
+        }
+        System.out.println(Arrays.toString(nums));
+    }
+
+    public static void main(String[] args) {
+
+        int[] nums = {1, 2, 3, 4, 5, 6, 7};
+        int[] nums2 = {-1, -100, 3, 99};
+
+        int[] nums3 = {-1, -100, 3};
+        int[] nums4 = {1, 2};
+        int[] nums5 = {1, 2, 3, 4, 5, 6};
+        int[] nums6 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45};
+
+
+        System.out.println(nums6.length);
+        rotate(nums6, 36);
+    }
+}
Index: DailyChallenges/November2023/NumberOf1Bits.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/NumberOf1Bits.java b/DailyChallenges/November2023/NumberOf1Bits.java
new file mode 100644
--- /dev/null	(date 1701423076438)
+++ b/DailyChallenges/November2023/NumberOf1Bits.java	(date 1701423076438)
@@ -0,0 +1,23 @@
+package DailyChallenges.November2023;
+//https://leetcode.com/problems/number-of-1-bits/description/?envType=daily-question&envId=2023-11-29
+//Sovlved
+
+public class NumberOf1Bits {
+
+    // you need to treat n as an unsigned value
+    public static int hammingWeight(int n) {
+
+        int amountOfOnes = 0;
+
+        while (n != 0) {
+            amountOfOnes = amountOfOnes + (1 & n);
+            n = n >>> 1;
+        }
+
+        return amountOfOnes;
+    }
+
+    public static void main(String[] args) {
+        System.out.println();
+    }
+}
Index: DailyChallenges/November2023/MinimumOneBitOperationsToMakeIntegersZero.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/MinimumOneBitOperationsToMakeIntegersZero.java b/DailyChallenges/November2023/MinimumOneBitOperationsToMakeIntegersZero.java
new file mode 100644
--- /dev/null	(date 1701429606233)
+++ b/DailyChallenges/November2023/MinimumOneBitOperationsToMakeIntegersZero.java	(date 1701429606233)
@@ -0,0 +1,45 @@
+package DailyChallenges.November2023;
+
+import java.util.Stack;
+
+//https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/description/?envType=daily-question&envId=2023-11-30
+public class MinimumOneBitOperationsToMakeIntegersZero {
+
+    public static int minimumOneBitOperations(int n) {
+
+        if (n == 0) {
+            return 0;
+        }
+        String binaryRepresentation = Integer.toBinaryString(n);
+        Stack<Integer> powers = new Stack<>();
+        int powerCounter = 0;
+
+        for (int i = binaryRepresentation.length() - 1; i >= 0; i--) {
+            char bit = binaryRepresentation.charAt(i);
+            if (bit == '1') {
+                powers.push(powerCounter);
+            }
+            powerCounter++;
+        }
+
+        int totalOperations = (int) Math.pow(2, powers.pop() + 1) - 1;
+        boolean isNextOperationSubtraction = true;
+
+        while (!powers.isEmpty()) {
+
+            if (isNextOperationSubtraction) {
+                totalOperations -= (int) Math.pow(2, powers.pop() + 1) - 1;
+                isNextOperationSubtraction = false;
+            } else {
+                totalOperations += (int) Math.pow(2, powers.pop() + 1) - 1;
+                isNextOperationSubtraction = true;
+            }
+        }
+
+        return totalOperations;
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: LeetCode.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LeetCode.txt b/LeetCode.txt
new file mode 100644
--- /dev/null	(date 1697360707168)
+++ b/LeetCode.txt	(date 1697360707168)
@@ -0,0 +1,96 @@
+[Arrays and Hashing]
+ -Contains duplicate:
+	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
+	
+	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
+	
+ -Valid Anagram:
+	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
+				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
+				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
+	
+	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
+			    in the second string, which is slower.
+	
+	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.
+
+ -Two Sum:
+	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
+				target, return the indexes.
+	
+	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
+				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
+				the index of the current key and the index of the found contained key.
+	
+	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
+	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
+																gets removed and the time complexity goes down to O(n).
+															
+ -Group Anagrams:
+ 
+
+
+ -Top K Frequent Elements:
+	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
+			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
+			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
+			  then remove that value from the list.
+	
+	-PriorityQueue.								  
+	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
+	
+	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
+				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
+				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
+	
+ -Product of Array Except Self:
+
+ -The rest I didn't finish describing, since I got lazy
+
+[Two Pointers]
+ -Valid Palindrome:
+	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
+	
+Здравейте, Атанас,
+
+С приятелите ми планираме новогодишен престой във Велико Търново и се интересуваме за някои въпроси за отсядането във вашата къща за гости.
+ 
+- Желаем да останем за 2 нощувки, от 30 декември до 1 януари. Бихте ли могли да потвърдите дали мястото е свободно за тези дати?
+- Изисквате ли депозит и ако да, какъв е размерът му и какъв е редът за възстановяването му?
+
+Освен това ще се радваме да получим ако има друга информация, с която смятате, че трябва да сме запознати.
+
+Поздрави,
+Мартин
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Здравейте Атанас, 
+
+С група приятели планираме новогодишен престой във Велико Търново и в тази
+връзка имаме няколко въпроса относно отсядане във Вашата къща за гости "еликите". 
+
+Желаем да останем за 2 нощувки - от 30 декември до 1 януари. Бихте ли 
+потвърдили дали датите са свободни? 
+
+Също така изисквате ли депозит и ако да, какъв е размерът му? 
+
+Ще се радваме да получим обратна връзка, ако имате въпроси към нас или ако
+искате да споделите друга информация, която смятате, че трябва да знаем. 
+
+Поздрави, 
+Мартин
\ No newline at end of file
Index: DailyChallenges/November2023/KnightDialer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/KnightDialer.java b/DailyChallenges/November2023/KnightDialer.java
new file mode 100644
--- /dev/null	(date 1701429543269)
+++ b/DailyChallenges/November2023/KnightDialer.java	(date 1701429543269)
@@ -0,0 +1,15 @@
+package DailyChallenges.November2023;
+
+//https://leetcode.com/problems/knight-dialer/description/?envType=daily-question&envId=2023-11-27
+//UNSOLVED
+public class KnightDialer {
+
+    public static int knightDialer(int n) {
+        return 0;
+    }
+
+    public static void main(String[] args) {
+
+      
+    }
+}
Index: DailyChallenges/November2023/LargestSubmatrixWithRearrangements.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/LargestSubmatrixWithRearrangements.java b/DailyChallenges/November2023/LargestSubmatrixWithRearrangements.java
new file mode 100644
--- /dev/null	(date 1701423076432)
+++ b/DailyChallenges/November2023/LargestSubmatrixWithRearrangements.java	(date 1701423076432)
@@ -0,0 +1,35 @@
+package DailyChallenges.November2023;
+//https://leetcode.com/problems/largest-submatrix-with-rearrangements/description/?envType=daily-question&envId=2023-11-26
+
+import java.util.Arrays;
+
+public class LargestSubmatrixWithRearrangements {
+
+    public static int largestSubmatrix(int[][] matrix) {
+        int rows = matrix.length;
+        int cols = matrix[0].length;
+        int maxArea = 0;
+
+        int[] h = new int[cols];
+
+        for (int i = 0; i < rows; i++) {
+            for (int j = 0; j < cols; j++)
+                h[j] = matrix[i][j] == 0 ? 0 : h[j] + 1;
+            int[] sortedH = Arrays.copyOf(h, h.length);
+            Arrays.sort(sortedH);
+            for (int j = 0; j < cols; j++)
+                maxArea = Math.max(maxArea, sortedH[j] * (cols - j));
+        }
+        return maxArea;
+    }
+
+    public static void main(String[] args) {
+        int[][] matrix = {
+                {0, 0, 1},
+                {1, 1, 1},
+                {1, 0, 1}
+        };
+
+        System.out.println(largestSubmatrix(matrix));
+    }
+}
Index: DailyChallenges/November2023/SumOfAbsoluteDifferencesInASortedArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/SumOfAbsoluteDifferencesInASortedArray.java b/DailyChallenges/November2023/SumOfAbsoluteDifferencesInASortedArray.java
new file mode 100644
--- /dev/null	(date 1701429643553)
+++ b/DailyChallenges/November2023/SumOfAbsoluteDifferencesInASortedArray.java	(date 1701429643553)
@@ -0,0 +1,35 @@
+package DailyChallenges.November2023;
+
+//https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/description/?envType=daily-question&envId=2023-11-25
+//SOLVED
+
+
+public class SumOfAbsoluteDifferencesInASortedArray {
+
+    public static int[] getSumAbsoluteDifferences(int[] nums) {
+
+        int[] result = new int[nums.length];
+        int totalSum = 0;
+        int sumUntilNow = 0;
+
+        for (int i = 0; i < nums.length; i++) {
+            totalSum += nums[i];
+        }
+
+        for (int i = 0; i < nums.length; i++) {
+            int absSumBeforehand = i * nums[i] - sumUntilNow;
+            int currentNumber = nums[i];
+
+            result[i] = absSumBeforehand + Math.abs((nums.length - i) * currentNumber - totalSum);
+
+            sumUntilNow += nums[i];
+            totalSum -= nums[i];
+        }
+
+        return result;
+    }
+
+    public static void main(String[] args) {
+        
+    }
+}
Index: LeetCode.rtf
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LeetCode.rtf b/LeetCode.rtf
new file mode 100644
--- /dev/null	(date 1698235938037)
+++ b/LeetCode.rtf	(date 1698235938037)
@@ -0,0 +1,88 @@
+[Arrays and Hashing]
+ -Contains duplicate:
+	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
+	
+	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
+	
+ -Valid Anagram:
+	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
+				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
+				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
+	
+	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
+			    in the second string, which is slower.
+	
+	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.
+
+ -Two Sum:
+	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
+				target, return the indexes.
+	
+	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
+				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
+				the index of the current key and the index of the found contained key.
+	
+	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
+	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
+																gets removed and the time complexity goes down to O(n).
+															
+ -Group Anagrams:
+ 
+
+
+ -Top K Frequent Elements:
+	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
+			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
+			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
+			  then remove that value from the list.
+	
+	-PriorityQueue.								  
+	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
+	
+	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
+				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
+				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
+	
+ -Product of Array Except Self:
+ 	-The rest I didn't finish describing, since I got lazy
+
+[Two Pointers]
+ -Valid Palindrome:
+	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything [replaceAll("[^a-zA-Z0-9]", "").toLowerCase();]. Check 	if the input string is empty, if yes -> return TRUE. Then use one for loop with two pointers, one at the beginning and one at the end. Both of them simultaniously iterate to the middle and check if each character from the beginning and the end are the same. If there's a mismatch return FALSE, else CONTINUE.
+
+ -Two Sum II Input Array Is Sorted:
+	-Place one pointer at the beginning and at the end of the array. "amountNeeded = target - array[beginningIndex]". Check if the "amountNeeded" is less than the number shown from the right-side pointer. If that's the case, move the right index 1 spot to the left and do the check again. If "amountNeeded" is greater than the number shown from the left-side pointer, then move the left index 1 spot to the right and do the check again. Eventually the "amountNeeded" will match with the number from the right idex and when that happens, return their places.
+
+ -3Sum:
+  - CURRENTLY ON HOLD
+
+ -Container With Most Water:
+	-DISCLAIMER:{I saw the solution first and then implemented it.} Create two pointers, one on the left side of the array and one on the right side of the array. Calculate the amount of water between them and mark it as highest amount if it's more than the previous highest amount. Then check if the value in the left pointer is higher than the valuein the right pointer. If that's the case, reduce the right pointer by one, otherwise increase the left pointer by one. Continue this loop until both pointers meet.
+
+ -Trapping Rain Water:
+	Traverse from left to right with two pointers at the spots [0] and [1]. Check if the rightValue is lower than the leftValue and if that's the case, calculate the difference between both values (that's the water that is going to get trapped) then increase the second pointer by one. If the rightValue is higher/ equal than the leftValue that means that no water can be trapped => update the total trapped water by the amount that has been calculated so far and set the two pointers as follows: begin = current higher Right end value, end = current higher Right end value +1. This loop will happen until we reach the highest point ever after which one there isn't a higher one. When that happens, we iterate to the end and remember at which index this highest point is and we discard all the collected water from that point on, since we don't know if there is any spillage on the right side. Then we do another reverse loop starting from the end with two pointers [endIndex] [endIndex-1] and we iterate with the above mentioned process until we reach the previously noted highest point.
+
+	
+[Sliding Window]
+ -Best Time To Buy And Sell Stock:
+	-DISCLAIMER:{Super retarted solution by me once again, atleast its O(n) and didn't use O(n^2) algo} Check for consecutive descending values in the beginning of the array(they are useless, we will never buy high and sell low) and note the next non-descending one as the beginning + if we reach the end it means that the whole array is descending => we can check that and return 0. Do the same but from the end - ascending values. Then iterate trough the array from the first relevant beginning entry to the first relevant end entry and note the index of the highest and the lowest number. If the index of the lowest number is before the index of the highest number return prices[highestIndex]-prices[lowestIndex]. In the other case do 2 more for loops: From the highest index backwards and from the lowest index forwards. Note the greatest difference in each of those two loops and return it.
+
+ -Length Of Longest Substring:
+	-I did two solutions, but both of them failed on the last test becase it ran for too long (35k) String. 
+	[1] Create a set holding the current characters and iterate trough the input String. Each time check if the new character is contained by the set. If that's the case, find the position of the character and update the iterating pointer one to the right of the first appearance of the repeated character, clear the set and continue from the new place.
+
+	[2] Sliding window implementation, but still 1 test case short. Create a Deque and start iterating and adding the characters to it until we find a duplicate. If found, check if the current Deque size is bigger than the highest number that we have found so far. Then continue removing characters from the head of the Deque until the contains() check fails and afterwards continue as normal - incrementing the right pointer and continuing to add new characters to the Deque.
+
+	[3] I finally gave up with this final test and asked ChatGPT for a solution. We create an array to keep track of the index of the last occurance of each character new int[256]. Create left and right pointer and while right<string.len, get the character at the right pointer and check if the character has been encountered withing the current window. If yes, update left to charIndex[character]. If not, calculate the length of the current substring and update the longestSubstringCount if necessary. Then update the character's index to the current position charIndex[character] = right + 1 and move the right pointer to the next character
+
+ -Longest Repeating Character Replacement:
+	-CURRENTLY ON HOLD
+
+ -Permutation In String:
+ 	-Improvement from 1000ms to 130ms or so with the use of array, containing the letters instead of a HashMap, still not the most optimal solution, should do this problem again at some point later on.
+
+	Create an array for the 26 letters in the alphabet and iterate trough the first string and update their frequency count. Create a copy of it and iterate trough the second(longer) string and reduce the occurances by one for each letter in it. Then iterate trough that array and if there's a character, which has been used in the first string but not in the second one, it's value should be > 0. If that's not the case return false (cannot have it being in the substring string part, but not in the second string). Then using the sliding window method iterate trough the second string. The window has the length of the first string. If the character in the string occurs in the array, reduce the array's value by one and update the left pointer and a counter. The counter is there to check if it matches the first string's length. If that's the case, return true (a permutated substring has been found). If the character in the string doesn't occur in the array, update the left pointer to the initial left pointer's value +1, update the right pointer by one, reset the counter to 0 and return the array to it's previous state (before making the changes during the current iteration). That way we creep slowly trough the second string, we are updating the window only by 1 for each iteration, which is kinda slow. 
+
+ -Minimum Window Substring:
+
+	-The character is from the substring and hasn't occured yet: decrease,
\ No newline at end of file
Index: DailyChallenges/November2023/NumberOfWaysToDivideALongCorridor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/November2023/NumberOfWaysToDivideALongCorridor.java b/DailyChallenges/November2023/NumberOfWaysToDivideALongCorridor.java
new file mode 100644
--- /dev/null	(date 1701423076418)
+++ b/DailyChallenges/November2023/NumberOfWaysToDivideALongCorridor.java	(date 1701423076418)
@@ -0,0 +1,68 @@
+package DailyChallenges.November2023;
+
+//https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/description/?envType=daily-question&envId=2023-11-28
+//SOLVED
+
+public class NumberOfWaysToDivideALongCorridor {
+    public static int numberOfWays(String corridor) {
+
+        long amountOfSeats = corridor.chars().filter(ch -> ch == 'S').count();
+
+        if (amountOfSeats == 2) {
+            return 1;
+        } else if (amountOfSeats < 2 || amountOfSeats % 2 == 1) {
+            return 0;
+        }
+        final int MODULO = (int) Math.pow(10, 9) + 7;
+        long result = 0;
+
+        boolean isFirstOfTwoChairsEnountered = false;
+        boolean isPairOfChairsFound = false;
+
+        int amountOfPossibleSeparations = 0;
+
+        for (int i = 0; i < corridor.length(); i++) {
+
+            char currentChar = corridor.charAt(i);
+
+            if (isPairOfChairsFound) {
+                if (currentChar == 'P') {
+                    amountOfPossibleSeparations++;
+                } else {
+                    result = result == 0 ? amountOfPossibleSeparations
+                            : (result * amountOfPossibleSeparations) % MODULO;
+                    amountOfPossibleSeparations = 0;
+                    isPairOfChairsFound = false;
+                    isFirstOfTwoChairsEnountered = true;
+                }
+                continue;
+            }
+
+            if (isFirstOfTwoChairsEnountered) {
+                if (currentChar == 'P') {
+                    continue;
+                } else {
+                    isFirstOfTwoChairsEnountered = false;
+                    isPairOfChairsFound = true;
+                    amountOfPossibleSeparations++;
+                }
+
+            } else {
+                if (currentChar == 'S') {
+                    isFirstOfTwoChairsEnountered = true;
+                }
+            }
+
+        }
+
+        return (int) result % MODULO;
+
+    }
+
+    public static void main(String[] args) {
+
+        String corridor = "SSPPSPS";
+        System.out.println(numberOfWays(corridor));
+
+    }
+}
Index: DailyChallenges/December2023/CheckIfTwoStringArraysAreEquivalent01_12.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DailyChallenges/December2023/CheckIfTwoStringArraysAreEquivalent01_12.java b/DailyChallenges/December2023/CheckIfTwoStringArraysAreEquivalent01_12.java
new file mode 100644
--- /dev/null	(date 1701424891312)
+++ b/DailyChallenges/December2023/CheckIfTwoStringArraysAreEquivalent01_12.java	(date 1701424891312)
@@ -0,0 +1,48 @@
+package DailyChallenges.December2023;
+
+//https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/description/?envType=daily-question&envId=2023-12-01
+//SOLVED
+public class CheckIfTwoStringArraysAreEquivalent01_12 {
+
+
+    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
+        int currentLetterIndexWord1 = 0;
+        int currentLetterIndexWord2 = 0;
+        int currentArrayIndexWord1 = 0;
+        int currentArrayIndexWord2 = 0;
+
+        while (currentArrayIndexWord1 < word1.length || currentArrayIndexWord2 < word2.length) {
+
+            char firstArrayLetter = word1[currentArrayIndexWord1].charAt(currentLetterIndexWord1);
+            char secondArrayLetter = word2[currentArrayIndexWord2].charAt(currentLetterIndexWord2);
+
+            if (firstArrayLetter != secondArrayLetter) {
+                return false;
+            }
+
+
+            if (currentLetterIndexWord1 + 1 == word1[currentArrayIndexWord1].length()) {
+                currentLetterIndexWord1 = 0;
+                currentArrayIndexWord1++;
+            } else {
+                currentLetterIndexWord1++;
+            }
+
+            if (currentLetterIndexWord2 + 1 == word2[currentArrayIndexWord2].length()) {
+                currentLetterIndexWord2 = 0;
+                currentArrayIndexWord2++;
+            } else {
+                currentLetterIndexWord2++;
+            }
+
+            if ((currentArrayIndexWord1 == word1.length && currentArrayIndexWord2 < word2.length) || (currentArrayIndexWord2 == word2.length && currentArrayIndexWord1 < word1.length)) {
+                return false;
+            }
+
+        }
+
+        return true;
+    }
+
+
+}
Index: LeetCode Workplace.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LeetCode Workplace.iml b/LeetCode Workplace.iml
new file mode 100644
--- /dev/null	(date 1701256669168)
+++ b/LeetCode Workplace.iml	(date 1701256669168)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/NeetCode" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1701429217325)
+++ b/.idea/vcs.xml	(date 1701429217325)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1701256669222)
+++ b/.idea/misc.xml	(date 1701256669222)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="17" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1701256669212)
+++ b/.idea/modules.xml	(date 1701256669212)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/LeetCode Workplace.iml" filepath="$PROJECT_DIR$/LeetCode Workplace.iml" />
+      <module fileurl="file://$PROJECT_DIR$/NeetCode/NeetCode.iml" filepath="$PROJECT_DIR$/NeetCode/NeetCode.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1701256669348)
+++ b/.idea/.gitignore	(date 1701256669348)
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
Index: out/production/LeetCode Workplace/LeetCode Workplace.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/LeetCode Workplace.iml b/out/production/LeetCode Workplace/LeetCode Workplace.iml
new file mode 100644
--- /dev/null	(date 1701256669168)
+++ b/out/production/LeetCode Workplace/LeetCode Workplace.iml	(date 1701256669168)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/NeetCode" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: out/production/LeetCode Workplace/LeetCode.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/LeetCode.txt b/out/production/LeetCode Workplace/LeetCode.txt
new file mode 100644
--- /dev/null	(date 1697360707168)
+++ b/out/production/LeetCode Workplace/LeetCode.txt	(date 1697360707168)
@@ -0,0 +1,96 @@
+[Arrays and Hashing]
+ -Contains duplicate:
+	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
+	
+	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
+	
+ -Valid Anagram:
+	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
+				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
+				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
+	
+	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
+			    in the second string, which is slower.
+	
+	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.
+
+ -Two Sum:
+	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
+				target, return the indexes.
+	
+	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
+				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
+				the index of the current key and the index of the found contained key.
+	
+	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
+	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
+																gets removed and the time complexity goes down to O(n).
+															
+ -Group Anagrams:
+ 
+
+
+ -Top K Frequent Elements:
+	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
+			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
+			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
+			  then remove that value from the list.
+	
+	-PriorityQueue.								  
+	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
+	
+	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
+				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
+				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
+	
+ -Product of Array Except Self:
+
+ -The rest I didn't finish describing, since I got lazy
+
+[Two Pointers]
+ -Valid Palindrome:
+	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
+	
+Здравейте, Атанас,
+
+С приятелите ми планираме новогодишен престой във Велико Търново и се интересуваме за някои въпроси за отсядането във вашата къща за гости.
+ 
+- Желаем да останем за 2 нощувки, от 30 декември до 1 януари. Бихте ли могли да потвърдите дали мястото е свободно за тези дати?
+- Изисквате ли депозит и ако да, какъв е размерът му и какъв е редът за възстановяването му?
+
+Освен това ще се радваме да получим ако има друга информация, с която смятате, че трябва да сме запознати.
+
+Поздрави,
+Мартин
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Здравейте Атанас, 
+
+С група приятели планираме новогодишен престой във Велико Търново и в тази
+връзка имаме няколко въпроса относно отсядане във Вашата къща за гости "еликите". 
+
+Желаем да останем за 2 нощувки - от 30 декември до 1 януари. Бихте ли 
+потвърдили дали датите са свободни? 
+
+Също така изисквате ли депозит и ако да, какъв е размерът му? 
+
+Ще се радваме да получим обратна връзка, ако имате въпроси към нас или ако
+искате да споделите друга информация, която смятате, че трябва да знаем. 
+
+Поздрави, 
+Мартин
\ No newline at end of file
Index: out/production/LeetCode Workplace/LeetCode.rtf
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/LeetCode.rtf b/out/production/LeetCode Workplace/LeetCode.rtf
new file mode 100644
--- /dev/null	(date 1698235938037)
+++ b/out/production/LeetCode Workplace/LeetCode.rtf	(date 1698235938037)
@@ -0,0 +1,88 @@
+[Arrays and Hashing]
+ -Contains duplicate:
+	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
+	
+	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
+	
+ -Valid Anagram:
+	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
+				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
+				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
+	
+	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
+			    in the second string, which is slower.
+	
+	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.
+
+ -Two Sum:
+	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
+				target, return the indexes.
+	
+	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
+				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
+				the index of the current key and the index of the found contained key.
+	
+	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
+	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
+																gets removed and the time complexity goes down to O(n).
+															
+ -Group Anagrams:
+ 
+
+
+ -Top K Frequent Elements:
+	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
+			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
+			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
+			  then remove that value from the list.
+	
+	-PriorityQueue.								  
+	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
+	
+	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
+				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
+				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
+	
+ -Product of Array Except Self:
+ 	-The rest I didn't finish describing, since I got lazy
+
+[Two Pointers]
+ -Valid Palindrome:
+	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything [replaceAll("[^a-zA-Z0-9]", "").toLowerCase();]. Check 	if the input string is empty, if yes -> return TRUE. Then use one for loop with two pointers, one at the beginning and one at the end. Both of them simultaniously iterate to the middle and check if each character from the beginning and the end are the same. If there's a mismatch return FALSE, else CONTINUE.
+
+ -Two Sum II Input Array Is Sorted:
+	-Place one pointer at the beginning and at the end of the array. "amountNeeded = target - array[beginningIndex]". Check if the "amountNeeded" is less than the number shown from the right-side pointer. If that's the case, move the right index 1 spot to the left and do the check again. If "amountNeeded" is greater than the number shown from the left-side pointer, then move the left index 1 spot to the right and do the check again. Eventually the "amountNeeded" will match with the number from the right idex and when that happens, return their places.
+
+ -3Sum:
+  - CURRENTLY ON HOLD
+
+ -Container With Most Water:
+	-DISCLAIMER:{I saw the solution first and then implemented it.} Create two pointers, one on the left side of the array and one on the right side of the array. Calculate the amount of water between them and mark it as highest amount if it's more than the previous highest amount. Then check if the value in the left pointer is higher than the valuein the right pointer. If that's the case, reduce the right pointer by one, otherwise increase the left pointer by one. Continue this loop until both pointers meet.
+
+ -Trapping Rain Water:
+	Traverse from left to right with two pointers at the spots [0] and [1]. Check if the rightValue is lower than the leftValue and if that's the case, calculate the difference between both values (that's the water that is going to get trapped) then increase the second pointer by one. If the rightValue is higher/ equal than the leftValue that means that no water can be trapped => update the total trapped water by the amount that has been calculated so far and set the two pointers as follows: begin = current higher Right end value, end = current higher Right end value +1. This loop will happen until we reach the highest point ever after which one there isn't a higher one. When that happens, we iterate to the end and remember at which index this highest point is and we discard all the collected water from that point on, since we don't know if there is any spillage on the right side. Then we do another reverse loop starting from the end with two pointers [endIndex] [endIndex-1] and we iterate with the above mentioned process until we reach the previously noted highest point.
+
+	
+[Sliding Window]
+ -Best Time To Buy And Sell Stock:
+	-DISCLAIMER:{Super retarted solution by me once again, atleast its O(n) and didn't use O(n^2) algo} Check for consecutive descending values in the beginning of the array(they are useless, we will never buy high and sell low) and note the next non-descending one as the beginning + if we reach the end it means that the whole array is descending => we can check that and return 0. Do the same but from the end - ascending values. Then iterate trough the array from the first relevant beginning entry to the first relevant end entry and note the index of the highest and the lowest number. If the index of the lowest number is before the index of the highest number return prices[highestIndex]-prices[lowestIndex]. In the other case do 2 more for loops: From the highest index backwards and from the lowest index forwards. Note the greatest difference in each of those two loops and return it.
+
+ -Length Of Longest Substring:
+	-I did two solutions, but both of them failed on the last test becase it ran for too long (35k) String. 
+	[1] Create a set holding the current characters and iterate trough the input String. Each time check if the new character is contained by the set. If that's the case, find the position of the character and update the iterating pointer one to the right of the first appearance of the repeated character, clear the set and continue from the new place.
+
+	[2] Sliding window implementation, but still 1 test case short. Create a Deque and start iterating and adding the characters to it until we find a duplicate. If found, check if the current Deque size is bigger than the highest number that we have found so far. Then continue removing characters from the head of the Deque until the contains() check fails and afterwards continue as normal - incrementing the right pointer and continuing to add new characters to the Deque.
+
+	[3] I finally gave up with this final test and asked ChatGPT for a solution. We create an array to keep track of the index of the last occurance of each character new int[256]. Create left and right pointer and while right<string.len, get the character at the right pointer and check if the character has been encountered withing the current window. If yes, update left to charIndex[character]. If not, calculate the length of the current substring and update the longestSubstringCount if necessary. Then update the character's index to the current position charIndex[character] = right + 1 and move the right pointer to the next character
+
+ -Longest Repeating Character Replacement:
+	-CURRENTLY ON HOLD
+
+ -Permutation In String:
+ 	-Improvement from 1000ms to 130ms or so with the use of array, containing the letters instead of a HashMap, still not the most optimal solution, should do this problem again at some point later on.
+
+	Create an array for the 26 letters in the alphabet and iterate trough the first string and update their frequency count. Create a copy of it and iterate trough the second(longer) string and reduce the occurances by one for each letter in it. Then iterate trough that array and if there's a character, which has been used in the first string but not in the second one, it's value should be > 0. If that's not the case return false (cannot have it being in the substring string part, but not in the second string). Then using the sliding window method iterate trough the second string. The window has the length of the first string. If the character in the string occurs in the array, reduce the array's value by one and update the left pointer and a counter. The counter is there to check if it matches the first string's length. If that's the case, return true (a permutated substring has been found). If the character in the string doesn't occur in the array, update the left pointer to the initial left pointer's value +1, update the right pointer by one, reset the counter to 0 and return the array to it's previous state (before making the changes during the current iteration). That way we creep slowly trough the second string, we are updating the window only by 1 for each iteration, which is kinda slow. 
+
+ -Minimum Window Substring:
+
+	-The character is from the substring and hasn't occured yet: decrease,
\ No newline at end of file
Index: out/production/LeetCode Workplace/.idea/uiDesigner.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/.idea/uiDesigner.xml b/out/production/LeetCode Workplace/.idea/uiDesigner.xml
new file mode 100644
--- /dev/null	(date 1701256772371)
+++ b/out/production/LeetCode Workplace/.idea/uiDesigner.xml	(date 1701256772371)
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.svg" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
\ No newline at end of file
Index: out/production/LeetCode Workplace/.idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/.idea/.gitignore b/out/production/LeetCode Workplace/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1701256669348)
+++ b/out/production/LeetCode Workplace/.idea/.gitignore	(date 1701256669348)
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
Index: out/production/LeetCode Workplace/.idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/.idea/modules.xml b/out/production/LeetCode Workplace/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1701256669212)
+++ b/out/production/LeetCode Workplace/.idea/modules.xml	(date 1701256669212)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/LeetCode Workplace.iml" filepath="$PROJECT_DIR$/LeetCode Workplace.iml" />
+      <module fileurl="file://$PROJECT_DIR$/NeetCode/NeetCode.iml" filepath="$PROJECT_DIR$/NeetCode/NeetCode.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/uiDesigner.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
--- /dev/null	(date 1701256772371)
+++ b/.idea/uiDesigner.xml	(date 1701256772371)
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.svg" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
\ No newline at end of file
Index: out/production/LeetCode Workplace/.idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/.idea/misc.xml b/out/production/LeetCode Workplace/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1701256669222)
+++ b/out/production/LeetCode Workplace/.idea/misc.xml	(date 1701256669222)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="17" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: Easy/ConvertIntegerToTheSumOfTwoNoZeroIntegers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/ConvertIntegerToTheSumOfTwoNoZeroIntegers.java b/Easy/ConvertIntegerToTheSumOfTwoNoZeroIntegers.java
new file mode 100644
--- /dev/null	(date 1701257251009)
+++ b/Easy/ConvertIntegerToTheSumOfTwoNoZeroIntegers.java	(date 1701257251009)
@@ -0,0 +1,27 @@
+package Easy;
+//https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/description/
+//SOLVED
+
+import java.util.Arrays;
+
+public class ConvertIntegerToTheSumOfTwoNoZeroIntegers {
+
+    public static int[] getNoZeroIntegers(int n) {
+        int a = 1;
+        int b = n - 1;
+
+        while (String.valueOf(a).contains("0") || String.valueOf(b).contains("0")) {
+            a++;
+            b--;
+        }
+
+        return new int[]{a, b};
+    }
+
+    public static void main(String[] args) {
+
+        int a = 1010;
+
+        System.out.println(Arrays.toString(getNoZeroIntegers(a)));
+    }
+}
Index: Easy/MergeSortedArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/MergeSortedArray.java b/Easy/MergeSortedArray.java
new file mode 100644
--- /dev/null	(date 1701429392663)
+++ b/Easy/MergeSortedArray.java	(date 1701429392663)
@@ -0,0 +1,63 @@
+package Easy;
+
+import java.util.Arrays;
+import java.util.PriorityQueue;
+
+//https://leetcode.com/problems/merge-sorted-array/description/
+
+public class MergeSortedArray {
+    public static void merge(int[] nums1, int m, int[] nums2, int n) {
+
+        PriorityQueue<Integer> numbersToBeInserted = new PriorityQueue<>();
+
+        for (int i = 0; i < nums1.length; i++) {
+
+            if ((m < n && i > m - 1) || (m > n && i > n - 1) || (m == n && i > n - 1)) {
+                if ((m < n && i < nums2.length) || (m > n && i < m)) {
+                    numbersToBeInserted.add((m < n) ? nums2[i] : nums1[i]);
+                }
+
+                nums1[i] = numbersToBeInserted.poll();
+                continue;
+            } else if (i == nums1.length - Math.abs(m - n) - 1) {
+                break;
+            }
+
+            if (numbersToBeInserted.isEmpty()) {
+                if (nums1[i] < nums2[i]) {
+                    numbersToBeInserted.add(nums2[i]);
+
+                } else {
+                    numbersToBeInserted.add(nums1[i]);
+                    nums1[i] = nums2[i];
+                }
+            } else {
+                int lowestToBeAdded = Math.min(numbersToBeInserted.peek(), Math.min(nums1[i], nums2[i]));
+                if (numbersToBeInserted.peek() == lowestToBeAdded) {
+                    numbersToBeInserted.add(nums1[i]);
+                    numbersToBeInserted.add(nums2[i]);
+                    nums1[i] = lowestToBeAdded;
+                    numbersToBeInserted.poll();
+                } else if (nums1[i] == lowestToBeAdded) {
+                    numbersToBeInserted.add(nums2[i]);
+
+                } else {
+                    numbersToBeInserted.add(nums1[i]);
+                    nums1[i] = nums2[i];
+                }
+            }
+        }
+
+        while (!numbersToBeInserted.isEmpty()) {
+            nums1[m] = numbersToBeInserted.poll();
+            m++;
+        }
+
+        System.out.println("Array state is: " + Arrays.toString(nums1));
+
+    }
+
+    public static void main(String[] args) {
+
+    }
+}
Index: out/production/LeetCode Workplace/.vscode/settings.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/LeetCode Workplace/.vscode/settings.json b/out/production/LeetCode Workplace/.vscode/settings.json
new file mode 100644
--- /dev/null	(date 1699256260607)
+++ b/out/production/LeetCode Workplace/.vscode/settings.json	(date 1699256260607)
@@ -0,0 +1,3 @@
+{
+   "editor.linkedEditing": true
+}
\ No newline at end of file
Index: Easy/FindLuckyIntegerInanArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/FindLuckyIntegerInanArray.java b/Easy/FindLuckyIntegerInanArray.java
new file mode 100644
--- /dev/null	(date 1700858639059)
+++ b/Easy/FindLuckyIntegerInanArray.java	(date 1700858639059)
@@ -0,0 +1,38 @@
+package Easy;
+
+// https://leetcode.com/problems/find-lucky-integer-in-an-array/
+// SOLVED
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+
+public class FindLuckyIntegerInanArray {
+
+   public static int findLucky(int[] arr) {
+      HashMap<Integer, Integer> numberToFrequency = new HashMap<>();
+      int highestNumber = -1;
+
+      for (int num : arr) {
+         numberToFrequency.put(num, numberToFrequency.getOrDefault(num, 0) + 1);
+      }
+
+      List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(numberToFrequency.entrySet());
+      ListIterator<Map.Entry<Integer, Integer>> reverseIterator = entries.listIterator(entries.size());
+
+      while (reverseIterator.hasPrevious()) {
+         Map.Entry<Integer, Integer> entry = reverseIterator.previous();
+         if (entry.getKey().equals(entry.getValue())) {
+            highestNumber = entry.getKey();
+            break;
+         }
+      }
+
+      return highestNumber;
+   }
+
+   public static void main(String[] args) {
+
+   }
+}
Index: Easy/NumberOfCommonFactors.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/NumberOfCommonFactors.java b/Easy/NumberOfCommonFactors.java
new file mode 100644
--- /dev/null	(date 1700850806731)
+++ b/Easy/NumberOfCommonFactors.java	(date 1700850806731)
@@ -0,0 +1,25 @@
+package Easy;
+
+//https://leetcode.com/problems/number-of-common-factors/description/
+//SOLVED
+public class NumberOfCommonFactors {
+   public static int commonFactors(int a, int b) {
+
+      int smallerNumber = Math.min(a, b);
+      int biggerNumber = Math.max(a, b);
+      int result = biggerNumber % smallerNumber == 0 ? 1 : 0;
+      // bruteForce
+      for (int i = 1; i < smallerNumber; i++) {
+         if (smallerNumber % i == 0 && biggerNumber % i == 0) {
+            result++;
+         }
+      }
+      return result;
+   }
+
+   public static void main(String[] args) {
+      int a = 1;
+      int b = 5;
+      System.out.println(commonFactors(a, b));
+   }
+}
Index: Easy/MakeTheStringGreat.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/MakeTheStringGreat.java b/Easy/MakeTheStringGreat.java
new file mode 100644
--- /dev/null	(date 1700855813431)
+++ b/Easy/MakeTheStringGreat.java	(date 1700855813431)
@@ -0,0 +1,47 @@
+package Easy;
+
+//https://leetcode.com/problems/make-the-string-great/description/
+//SOLVED
+import java.util.Stack;
+
+public class MakeTheStringGreat {
+   public static String makeGood(String s) {
+
+      Stack<Character> lettersStack = new Stack<>();
+
+      for (int i = 0; i < s.length(); i++) {
+         char currentChar = s.charAt(i);
+         boolean isCurrentCharUppercase = Character.isUpperCase(currentChar);
+
+         if (!lettersStack.isEmpty()) {
+            char previousChar = lettersStack.peek();
+            boolean isPreviousCharUppercase = Character.isUpperCase(previousChar);
+
+            boolean areBothCharsDifferentCasedAndSameValue = (isCurrentCharUppercase != isPreviousCharUppercase) &&
+                  (Character.toUpperCase(previousChar) == Character.toUpperCase(currentChar));
+
+            if (areBothCharsDifferentCasedAndSameValue) {
+               lettersStack.pop();
+            } else {
+               lettersStack.push(currentChar);
+            }
+
+         } else {
+            lettersStack.push(currentChar);
+         }
+      }
+
+      StringBuilder result = new StringBuilder();
+      for (Character ch : lettersStack) {
+         result.append(ch);
+      }
+
+      return result.toString();
+   }
+
+   public static void main(String[] args) {
+
+      String s = "leEeetcode";
+      System.out.println(makeGood(s));
+   }
+}
Index: Easy/ElementAppearingMoreThan25PercentInSortedArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/ElementAppearingMoreThan25PercentInSortedArray.java b/Easy/ElementAppearingMoreThan25PercentInSortedArray.java
new file mode 100644
--- /dev/null	(date 1700852250370)
+++ b/Easy/ElementAppearingMoreThan25PercentInSortedArray.java	(date 1700852250370)
@@ -0,0 +1,33 @@
+package Easy;
+
+//https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/description/
+
+//Solved
+
+import java.util.HashMap;
+
+public class ElementAppearingMoreThan25PercentInSortedArray { // Even faster is to check if the current element is the
+                                                              // same as the array[currentIndex+arr.length/4]
+
+   public static int findSpecialInteger(int[] arr) {
+      HashMap<Integer, Integer> numberToFrequency = new HashMap<>();
+      int result = 0;
+
+      for (int num : arr) {
+         numberToFrequency.put(num, numberToFrequency.getOrDefault(num, 0) + 1);
+
+         if (numberToFrequency.get(num) > arr.length / 4) {
+            result = num;
+            break;
+         }
+      }
+
+      return result;
+   }
+
+   public static void main(String[] args) {
+      int[] arr = { 1, 2, 2, 6, 6, 6, 6, 7, 10 };
+      System.out.println(findSpecialInteger(arr));
+   }
+
+}
Index: Easy/ConsecutiveCharacters.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/ConsecutiveCharacters.java b/Easy/ConsecutiveCharacters.java
new file mode 100644
--- /dev/null	(date 1700853607570)
+++ b/Easy/ConsecutiveCharacters.java	(date 1700853607570)
@@ -0,0 +1,34 @@
+package Easy;
+//https://leetcode.com/problems/consecutive-characters/description/
+//SOLVED
+import java.util.Arrays;
+
+public class ConsecutiveCharacters {
+   public static int maxPower(String s) {
+
+      int highestStreak = 0;
+      int currentStreak = 1;
+      char[] inputAsArray = s.toCharArray();
+      for (int i = 0; i < inputAsArray.length - 1; i++) {
+         if (inputAsArray[i] == inputAsArray[i + 1]) {
+            currentStreak++;
+         } else {
+            highestStreak = Math.max(currentStreak, highestStreak);
+            currentStreak = 1;
+            if (highestStreak > inputAsArray.length - i + 1) {
+               break;
+            }
+         }
+      }
+      return Math.max(highestStreak, currentStreak);
+   }
+
+   public static void main(String[] args) {
+
+      String s = "aasdddddsssbbbba";
+      char[] arr = s.toCharArray();
+      Arrays.sort(arr);
+      System.out.println(Arrays.toString(arr));
+      System.out.println(maxPower(s));
+   }
+}
Index: Easy/DeleteGreatestValueInEachRow.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/DeleteGreatestValueInEachRow.java b/Easy/DeleteGreatestValueInEachRow.java
new file mode 100644
--- /dev/null	(date 1700769325258)
+++ b/Easy/DeleteGreatestValueInEachRow.java	(date 1700769325258)
@@ -0,0 +1,39 @@
+package Easy;
+
+//https://leetcode.com/problems/delete-greatest-value-in-each-row/
+// SOLVED
+
+import java.util.Arrays;
+import java.util.Stack;
+
+public class DeleteGreatestValueInEachRow {
+   public static int deleteGreatestValue(int[][] grid) {
+
+      int result = 0;
+      Stack<Integer> stack = new Stack<>();
+
+      for (int[] row : grid) {
+         Arrays.sort(row);
+      }
+
+      for (int col = 0; col < grid[0].length; col++) {
+         for (int row = 0; row < grid.length; row++) {
+            int currentNumber = grid[row][col];
+            if (stack.isEmpty() || currentNumber > stack.peek()) {
+               stack.clear();
+               stack.push(currentNumber);
+            }
+
+         }
+         result += stack.pop();
+      }
+
+      return result;
+
+   }
+
+   public static void main(String[] args) {
+
+   }
+
+}
Index: Easy/MajorityElement.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Easy/MajorityElement.java b/Easy/MajorityElement.java
new file mode 100644
--- /dev/null	(date 1701250303261)
+++ b/Easy/MajorityElement.java	(date 1701250303261)
@@ -0,0 +1,26 @@
+package Easy;
+
+import java.util.Arrays;
+
+//https://leetcode.com/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150
+//SOLVED non linear time
+
+public class MajorityElement {
+   public int majorityElement(int[] nums) {
+
+      int half = (int) Math.ceil((double) nums.length / 2.0);
+      Arrays.sort(nums); // O(n logn). The solution isn't linear time O(n)
+      
+      for (int i = 0; i < nums.length; i += half) {
+         if (i + half >= nums.length || nums[i] == nums[i + half - 1]) {
+            return nums[i];
+         }
+      }
+
+      return 0;
+   }
+
+   public static void main(String[] args) {
+      System.out.println((int) Math.ceil((double) (3) / (double) (2)));
+   }
+}
Index: Medium/RemoveDuplicatesFromSortedArrayII.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Medium/RemoveDuplicatesFromSortedArrayII.java b/Medium/RemoveDuplicatesFromSortedArrayII.java
new file mode 100644
--- /dev/null	(date 1701197446753)
+++ b/Medium/RemoveDuplicatesFromSortedArrayII.java	(date 1701197446753)
@@ -0,0 +1,56 @@
+package Medium;
+
+//https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150
+//SOLVED
+
+public class RemoveDuplicatesFromSortedArrayII {
+
+   public static int removeDuplicates(int[] nums) {
+
+      int amountOfRemovedNumbers = 0;
+
+      boolean isThereRepetition = false;
+      boolean isIndexSet = false;
+
+      int nextFreeIndex = -1;
+
+      for (int i = 1; i < nums.length; i++) {
+
+         if (i == nums.length - 1 && !isThereRepetition && nums[i - 1] == nums[i] && isIndexSet) {
+            nums[nextFreeIndex] = nums[i];
+            break;
+         }
+
+         if (nums[i - 1] == nums[i]) {
+            if (!isThereRepetition) {
+               isThereRepetition = true;
+               if (nextFreeIndex > -1) {
+                  nums[nextFreeIndex] = nums[i];
+                  nextFreeIndex++;
+               }
+            } else {
+               if (isIndexSet) {
+                  amountOfRemovedNumbers++;
+               } else {
+                  nextFreeIndex = i;
+                  isIndexSet = true;
+                  amountOfRemovedNumbers++;
+               }
+            }
+         } else {
+            isThereRepetition = false;
+            if (nextFreeIndex > -1) {
+               nums[nextFreeIndex++] = nums[i];
+            }
+         }
+      }
+
+      return nums.length - amountOfRemovedNumbers;
+   }
+
+   public static void main(String[] args) {
+      int[] a = { 1, 1, 1, 2, 2, 3 };
+
+      removeDuplicates(a);
+   }
+}
Index: .vscode/settings.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
--- /dev/null	(date 1699256260607)
+++ b/.vscode/settings.json	(date 1699256260607)
@@ -0,0 +1,3 @@
+{
+   "editor.linkedEditing": true
+}
\ No newline at end of file
Index: NeetCode/Stack/LargestRectangleInHistogram.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/LargestRectangleInHistogram.java b/NeetCode/Stack/LargestRectangleInHistogram.java
new file mode 100644
--- /dev/null	(date 1701429959253)
+++ b/NeetCode/Stack/LargestRectangleInHistogram.java	(date 1701429959253)
@@ -0,0 +1,17 @@
+package Stack;
+
+public class LargestRectangleInHistogram {
+
+    public static int largestRectangleArea(int[] heights) {
+
+        int result = 0;
+
+        return result;
+
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+}
Index: NeetCode/Stack/GenerateParentheses.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/GenerateParentheses.java b/NeetCode/Stack/GenerateParentheses.java
new file mode 100644
--- /dev/null	(date 1701429936937)
+++ b/NeetCode/Stack/GenerateParentheses.java	(date 1701429936937)
@@ -0,0 +1,18 @@
+package Stack;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+public class GenerateParentheses {
+    public static List<String> generateParenthesis(int n) {
+
+        return null;
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+}
Index: NeetCode/Stack/DailyTemperatures.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/DailyTemperatures.java b/NeetCode/Stack/DailyTemperatures.java
new file mode 100644
--- /dev/null	(date 1701429884444)
+++ b/NeetCode/Stack/DailyTemperatures.java	(date 1701429884444)
@@ -0,0 +1,25 @@
+package Stack;
+
+import java.util.Stack;
+
+public class DailyTemperatures {
+
+    public static int[] dailyTemperatures(int[] temperatures) {
+        int[] result = new int[temperatures.length];
+        Stack<Integer> stack = new Stack<>();
+
+        for (int i = 0; i < temperatures.length; i++) {
+
+            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
+                int prevIndex = stack.pop();
+                result[prevIndex] = i - prevIndex;
+            }
+            stack.push(i);
+        }
+
+        return result;
+    }
+
+    public static void main(String[] args) {
+    }
+}
Index: NeetCode/Stack/EvaluateReversePolishNotation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/EvaluateReversePolishNotation.java b/NeetCode/Stack/EvaluateReversePolishNotation.java
new file mode 100644
--- /dev/null	(date 1701429936928)
+++ b/NeetCode/Stack/EvaluateReversePolishNotation.java	(date 1701429936928)
@@ -0,0 +1,46 @@
+package Stack;
+
+import java.util.Stack;
+
+public class EvaluateReversePolishNotation {
+
+    public static int evalRPN(String[] tokens) {
+        if (tokens.length == 1) {
+            return Integer.valueOf(tokens[0]);
+        }
+
+        Stack<Integer> valuesStack = new Stack<>();
+
+        for (int i = 0; i < tokens.length; i++) {
+            String token = tokens[i];
+            char firstChar = token.charAt(0);
+
+            if (Character.isDigit(firstChar) || (token.length() > 1 && firstChar == '-')) {
+                valuesStack.push(Integer.parseInt(token));
+            } else {
+                switch (token) {
+                    case "+":
+                        valuesStack.push(valuesStack.pop() + valuesStack.pop());
+                        break;
+                    case "-":
+                        valuesStack.push(-valuesStack.pop() + valuesStack.pop());
+                        break;
+
+                    case "*":
+                        valuesStack.push(valuesStack.pop() * valuesStack.pop());
+                        break;
+
+                    case "/":
+                        int divisor = valuesStack.pop();
+                        int divident = valuesStack.pop();
+                        valuesStack.push(divident / divisor);
+                        break;
+                }
+            }
+        }
+        return valuesStack.pop();
+    }
+
+    public static void main(String[] args) {
+    }
+}
Index: NeetCode/Stack/MinStack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/Stack/MinStack.java b/NeetCode/Stack/MinStack.java
new file mode 100644
--- /dev/null	(date 1701429964592)
+++ b/NeetCode/Stack/MinStack.java	(date 1701429964592)
@@ -0,0 +1,51 @@
+package Stack;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.PriorityQueue;
+import java.util.Stack;
+
+public class MinStack {
+
+    private Stack<Integer> stack;
+    private int currentMin;
+    private List<Integer> orderTracker;
+
+    public MinStack() {
+        currentMin = Integer.MAX_VALUE;
+        stack = new Stack<Integer>();
+        orderTracker = new ArrayList<>();
+    }
+
+    public void push(int val) {
+        currentMin = Math.min(currentMin, val);
+        stack.push(val);
+        orderTracker.add(val);
+        Collections.sort(orderTracker);
+    }
+
+    public void pop() {
+        int removedTopNumber = stack.pop();
+        int removedIndex = orderTracker.indexOf(removedTopNumber);
+        orderTracker.remove(removedIndex);
+
+        if (stack.isEmpty()) {
+            currentMin = Integer.MAX_VALUE;
+        } else {
+            if (removedTopNumber == currentMin) {
+                currentMin = orderTracker.get(0);
+            }
+        }
+
+    }
+
+    public int top() {
+        return stack.peek();
+    }
+
+    public int getMin() {
+        return currentMin;
+    }
+
+}
Index: NeetCode/BinarySearch/BinarySearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/NeetCode/BinarySearch/BinarySearch.java b/NeetCode/BinarySearch/BinarySearch.java
new file mode 100644
--- /dev/null	(date 1701261888722)
+++ b/NeetCode/BinarySearch/BinarySearch.java	(date 1701261888722)
@@ -0,0 +1,29 @@
+package BinarySearch;
+
+public class BinarySearch {
+
+    public static int search(int[] nums, int target) {
+        int left = 0;
+        int right = nums.length - 1;
+
+        while (left <= right) {
+            int middle = left + (right - left) / 2;
+
+            if (nums[middle] > target) {
+                right = middle - 1;
+            } else if (nums[middle] < target) {
+                left = middle + 1;
+            } else {
+                return middle;
+            }
+        }
+
+        return -1;
+    }
+
+    public static void main(String[] args) {
+        int[] nums = {-1, 0, 3, 5, 9, 12, 18};
+
+        System.out.println(search(nums, 3));
+    }
+}
