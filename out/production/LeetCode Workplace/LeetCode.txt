[Arrays and Hashing]
 -Contains duplicate:
	-HashSet. Check if the HashSet contains the current number from the array [iterate]. If yes, return TRUE. If not, add the number to the HashSet.
	
	-Sorting. Sort the array and compare each element with the one after it. If they are equal return TRUE.
	
 -Valid Anagram:
	-Char Count. Check for length first, if both strings have different lengths, return FALSE. Create an array with 26 elements [alphabet letters] and iterate trough the length
				 of the strings. For each character in the first string [charAt()], increase the value of the integer stored in the created array. For the secon string, decrease
				 the value of the integer at the correct index. At the end if all the array elements are 0, return TRUE.
	
	-My Idea 1. Same as above, but use HashMap. Result is the same, but I do one loop for the first string to set/ increase each value in the HashMap and another loop for the same
			    in the second string, which is slower.
	
	-My Idea 2. Sorting [Arrays.sort()] both arrays and iterate troughout the length. Check if the character at each index is the same, else return FALSE.

 -Two Sum:
	-My Idea 1. Bruteforce: Two nested for loops. Inner one iterates troughout the whole array starting from outer loop index + 1. If the result of the sum of both numbers is the 
				target, return the indexes.
	
	-My Idea 2. HashMap(After reading about using HashMap structure for the solution). Fill the HashMap with <Integer, int[]> pairs [number:indexInArray]. Then iterate trough the 
				keys and check if [key*2==target], if that's the case just return the 2 indexes stored at that key. Otherwise check if [HashMap.containsKey(target-key)] and return
				the index of the current key and the index of the found contained key.
	
	-Notes after Idea 2 and watching an example video solution. Instead of iterating once to fill the HashMap and once more trough the keys, which leads to time complexity of	
	[https://www.youtube.com/watch?v=BoHO04xVeU0]	            O(n^2), I can integrate the code used in the second loop in the first loop. That way the need of a second for loop 
																gets removed and the time complexity goes down to O(n).
															
 -Group Anagrams:
 


 -Top K Frequent Elements:
	-My Idea. {I don't like my implementation, because it's way too unoptimal}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. After that iterate
			  trough the HashMap and fill a new one frequencyToNumbers [int:List-NumbersApperedKeyAmountOfTimes] with swapped values. After that sort the keySet into a descending
			  order and iterate again trough it. While the result array topKFrequent[k] is empty, fill it up with the first element from each valueList from the mostFrequentKey and
			  then remove that value from the list.
	
	-PriorityQueue.								  
	[https://www.youtube.com/watch?v=6iLb_Z-osmQ] 
	
	-BucketSort. {This is the solution from one LeetCode submission}. Sort the input array and fill a HashMap numbersToFrequency [int:amountOfTimes]. Create a bucket 
				 List<Integer>[] bucket = new List[nums.length + 1]; Then iterate trough the values in the HashMap and if (bucket[frequency] == null) => create a new ArrayList inside
				 and then add the key into that List. Then iterate backwards trough the bucket and put the values from the existing indexes into the result array. 
	
 -Product of Array Except Self:

 -The rest I didn't finish describing, since I got lazy

[Two Pointers]
 -Valid Palindrome:
	-Clear the input to remove anything that isn't a letter or a number with a regex and transform everything replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
	
Здравейте, Атанас,

С приятелите ми планираме новогодишен престой във Велико Търново и се интересуваме за някои въпроси за отсядането във вашата къща за гости.
 
- Желаем да останем за 2 нощувки, от 30 декември до 1 януари. Бихте ли могли да потвърдите дали мястото е свободно за тези дати?
- Изисквате ли депозит и ако да, какъв е размерът му и какъв е редът за възстановяването му?

Освен това ще се радваме да получим ако има друга информация, с която смятате, че трябва да сме запознати.

Поздрави,
Мартин

















Здравейте Атанас, 

С група приятели планираме новогодишен престой във Велико Търново и в тази
връзка имаме няколко въпроса относно отсядане във Вашата къща за гости "еликите". 

Желаем да останем за 2 нощувки - от 30 декември до 1 януари. Бихте ли 
потвърдили дали датите са свободни? 

Също така изисквате ли депозит и ако да, какъв е размерът му? 

Ще се радваме да получим обратна връзка, ако имате въпроси към нас или ако
искате да споделите друга информация, която смятате, че трябва да знаем. 

Поздрави, 
Мартин